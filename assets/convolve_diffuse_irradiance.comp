#version 450
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : enable
#include "bindless.h"
#include "sh.h"
#include "hash.h"
#include "pbr.h"

layout(scalar, buffer_reference, buffer_reference_align=8) buffer IBLData
{
	SH_L2_RGB irradiance;
};

layout(scalar, push_constant) uniform uPushConstant {
	IBLData ibl_buffer;
} c_;

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint  local_idx  = gl_LocalInvocationIndex;
	uvec3 global_idx = gl_GlobalInvocationID;
	uvec3 group_idx  = gl_WorkGroupID;

	if (group_idx.x == 0) {
		SH_L2_RGB radiance_sh = SH_L2_RGB_Zero();

		float num_samples = 0.0;
#if 0
		const int NUM_SAMPLES = 128;
		for(int isample = 0; isample < NUM_SAMPLES; ++isample) {
			// Samples distribution doesn't look good...
			uvec3 rng = pcg3d(uvec3(isample, NUM_SAMPLES, 0));
			vec3 u3 = hash_to_float3(rng);
			float theta = 2.0 * M_PI * u3[0];
			float cos_phi = u3[1];
			float sin_phi = sqrt(1.0 - cos_phi * cos_phi);
			vec3 sample_dir = vec3(cos(theta) * sin_phi, sin(theta) * sin_phi, cos_phi);
			// This one is better!
			sample_dir = normalize(u3 * 2.0 - 1.0);

			vec3 sample_radiance = skyTex(sample_dir);
			radiance_sh = SH_Add(radiance_sh, SH_ProjectOntoL2_RGB(sample_dir, sample_radiance));
		}
		num_samples = NUM_SAMPLES;
#else
		// Bruteforce
		for (float theta = 0.0; theta <= 2.0 * M_PI; theta += 0.25) {
			for (float phi = 0.0; phi <= M_PI; phi += 0.25) {
				float cos_phi = cos(phi);
				float sin_phi = sqrt(1.0 - cos_phi * cos_phi);
				vec3 sample_dir = vec3(sin_phi*cos(theta), sin_phi*sin(theta), cos_phi);

				vec3 sample_radiance = skyTex(sample_dir);
				radiance_sh = SH_Add(radiance_sh, SH_ProjectOntoL2_RGB(sample_dir, sample_radiance));
				num_samples += 1.0;
			}
		}
#endif
		radiance_sh = SH_Divide(radiance_sh, vec3(num_samples));

		c_.ibl_buffer.irradiance = SH_ConvolveWithCosineLobe(radiance_sh);
	}
}
